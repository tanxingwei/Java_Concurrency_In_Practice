# 对象的组合

正确的理解应该是以类组合的方式去设计一个线程安全的类。

## 如何去设计一个线程安全的类

### 对象的状态集合

要分析对象的状态，需要先对象的域（类的实例字段）开始说起。如果一个对象的域都是基本类型， 那么这些域就构成了对象的全部状态。 例如：（x,y）这个二元组就是Point实例的状态集合。

```java
public class Point {
    private int x;
    private int y;
}
```

如果对象的域中包括引用对象， 那么该对象的状态将包括被应用对象域， 例如LinkedList的状态就包括链表中所有节点的对象的状态。

### 对象的同步需求

<font color="red">**同步需求是问题的描述， 同步策略是问题的解决方案**</font>

在多线程条件下， 类实例的期望运行逻辑。在开发的过程中需要使用一些同步机制来保证类的行为符合预期的运行， 例如保证可见性， 阻塞之类的。

需要注意的是， <font color="red">**分析同步需求时请勿假定存在任何同步机制**</font>， 同步需求是我们在并发场景下对类的期望运行状态的描述。例如存在一个累加器被A,B两个线程访问， 后验条件是newValue = oldValue + 1。但是没有同步机制的情况下， 后验条件是会被破坏的。

因此， 也可以把同步需求理解成， 一个类需要对哪些操作使用同步机制， 以保证自身的逻辑正常运行。

#### 不变性条件

运行过程中始终为真的条件， 例如ThreadPool中的线程池核心线程数不可小于零，最大线程数不能小于等于0， 且最大线程数大于核心线程数。而且需要注意的是， 一个类可能会有很多不同的不变性条件， 这些不变性条件的集合就构成了整个类的不变性条件。

#### 后验条件

实际上就是状态转换限制， 当属性A的值从oldValue变为newValue是需要遵守的规则。并且如果下一个状态要依赖当前状态的话， 这会是一个复合操作，还需要考虑可见性问题。以上面的累加器为例， newValuie如果不等于oldValue + 1, 那么newValue就是一个无效状态。当然也不是任何操作都有状态转换限制， 例如地图上用户的GPS地址。

#### 先验条件（基于状态的操作）

实例方法的执行逻辑依赖于某个状态， 例如阻塞队列取出元素或删除元素的前置条件都是当前队列不为空。

这里的情况一般就是阻塞直到队列不为空再继续执行实例方法剩余的业务逻辑。

### 对象的同步策略

同步策略实际上就是Java中的同步机制， 选用一种或者多种同步策略满足类的同步需求。

**互斥锁（Mutex）**：互斥锁是一种最基本的同步机制，用于确保在同一时间只有一个线程可以访问共享资源。线程在访问共享资源之前需要获取互斥锁，其他线程必须等待该锁的释放才能继续执行。
**读写锁（Read-Write Lock）**：读写锁允许多个线程同时进行读操作，但在写操作时需要独占访问。这种策略适用于读操作频繁且不会改变数据的场景，可以提高并发性能。
**信号量（Semaphore）**：信号量是一种计数器，用于控制同时访问某个资源的线程数量。它可以用来限制对资源的并发访问，也可以用于线程间的通信。
**条件变量（Condition Variable）**：条件变量允许线程在满足特定条件之前等待，并在条件满足时被其他线程唤醒。它通常与互斥锁结合使用，用于线程之间的协作和同步。
**屏障（Barrier）**：屏障用于使一组线程在某个点上等待，直到所有线程都到达该点才能继续执行。它可以用于同步线程的执行顺序，确保某些操作在所有线程都完成之后才继续进行。
**原子操作（Atomic Operation）**：原子操作是一种无需任何额外同步机制即可保证操作的原子性的方式。原子操作通常由底层硬件支持，可以用于实现简单的并发操作，如原子读取、写入和比较交换等。 **volatile和CAS**。

## 实例封闭

其本质就是线程封闭中的栈封闭, 也是OOP三大特性中的封装.

下面我们回顾一下OOP中对象的关系与OOP的三大特性

#### OOP中对象的关系

分别有继承,实现,依赖, 关联, 聚合,组合等六种关系.

继承与实现通常是没有疑问的,主要会有疑问的会是后四种关系.

**依赖**: 类B作为参数被类A在某个method方法中使用

```java
class A{
    private String bField;
    private void function1(B b){
        a.bField = b.getSomeField();
    }
}
```

**关联**:被关联类B以类的属性的形式出现在关联类A中，也可能是关联类A引用了一个类型为被关联类B的全局变量

```java
class A{
    private B b;
}
```

**聚合**:它体现的是整体与部分的关系，即has-a的关系。此时整体与部分之间是可分离的，它们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享。比如计算机与CPU、公司与员工的关系等.表现在代码层面，和关联关系是一致的，只能从语义级别来区分.

**组合**:它体现的是contains-a的关系，这种关系比聚合更强，也成为强聚合。它同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束，比如人和人的大脑。表现在代码层面，和关联关系是一致的,只能从语义级别来区分.

但总的来说，后几种关系所表现的强弱程度依次为：组合>聚合>关联>依赖。

![img](https://raw.githubusercontent.com/tanxingwei/bolgImg/master/2024/02/25/20240225-211125.png)

#### OOP的三大特性

**封装**:

实际上就是两层含义, 1. 将属性和行为封装起来, 作为一个整体. 2.就是权限控制, 仅暴露调用者需要知晓的信息.

**继承**:

这是一个创建新类的过程. 一方面这是对现实层次的的抽象,另一方面则是可以复用已存在的类

**多态**:

一个操作可以展现出不同的操作模式,主要有两种,:

* 一种是实现或继承同一个父类的兄弟类, 都以各自的方式**重写**了某个方法
* 另一种则是同一个类方法的**重载**, 例如嵌套构造函数

#### 状态的所有权问题

在具体聊封装和线程安全之前, 我们需要看一下对象所有权的问题.

**状态的所有权问题是指在编程中管理变量或对象的生命周期和内存分配的问题。所有权概念涉及到谁负责创建和销毁一个变量或对象，以及这些变量或对象如何被传递和共享**

而在多线程情况下, **状态的所有权问题与对象状态的并发访问策略(同步策略)是息息相关的**, 类仅需要考虑自己拥有的状态集合的同步策略, 保证状态集合的可见性.而对于一些共享变量, 其中的状态集合则是无权干涉的.

```java
public class PersonSet{
    private Rule rule;
    private final Set<Person> persons = new HashSet<Person>();

    public PersonSet(Rule rule){
        this.rule = rule;
    }
    
    public synchronized void addPerson(Person person){
        if (rule.computedAddPersonRule()){
            persons.add(person);
        }
    }
    
    public synchronized boolean containsPerson(Person person){
        return persons.contains(person);
    } 
}
```

如上所示, 在状态的所有权问题上, PersonSet的实例对象拥有persons集合的全部状态 并且PersonSet是需要被并发访问的, 由于hashSet不是线程安全的类型, 所以需要PersonSet做同步机制保证实例中的persons的数据一致性和可见性.但是对于外部传入的Rule实例对象, PersonSet并不拥有它的状态, Rule的实例是一个共享变量,其线程安全性需要自己维护.

所有权问题与封装通常是相关的:对象封装它有用的状态,反之也成立, 对它封装的状态拥有所有权.

一般而言, 对于从构造函数或方法中传入的作为参数的对象, 一般对象是不具有所有权的.

最后.根据我的浅薄理解, 对象的所有权问题实际上也是设计类的并发策略的边界问题.

#### 封装与线程安全

**封装会使类的可控性更高**, 将某个对象封装以后, 它的访问路径都是已知的, 如果该变量在多线程场景下会有读写的需求, 那么就需要额外再选择一个同步机制保护这个变量, 用以保证这个线程的安全性, 实际上这就是java监视器模式的原理.

当然, **这里有非常重要的一个点是,封装的对象不能溢出!!!**

#### Java监视器模式

实际上就是封闭机制以及同步机制, java监视器模式只是一种设计规约,下面给出一个案例:

````java
class Monitor{
    // 内置锁也可以换成LOCK接口的实现类, 例如ReentrantLock
    private Object lockObj = new Object();
    private ProtectedContent protectedContent;
    
    void someMethod(){
        synchronized (lockObj){
            // read or write ProtectedContent status
        }
    }
}
````

这里还有一个问题是, 为什么不用Monitor的内置锁, 而是选用私有的锁对象呢?

我觉得这个可以从性能和安全性上来考虑, 首先使用对象的内置锁, 这会导致什么? 访问该实例都要获取到这个锁才可以继续操作, **锁的粒度**是整个实例对象;并且. 对象的内置锁是可以被外部代码块获取的, 如果某个代码块不正确的获得了对象的内置锁, 可能会导致**活跃性问题**; 最后一个则是验证成本问题, 私有的锁对象如果不溢出的话, 只用关注类内的使用就可以了, 但是可共有访问的锁则是需要分析整个程序才可以判定.

## 线程安全的委托

实际上将自己的线程安全实现委托给内部封装的线程安全的组件,当然请注意不能破坏类的不变性条件.例如类的内部有一个累加器, 如果用监视器模式则需要手动加锁以保证线程安全性, 我们可以直接替换成原子类.

### 独立的状态变量

独立的状态变量是指状态变量之间没有相互依赖或影响的关系，每个状态变量只依赖于其自身的状态，而与其他状态变量无关.

例如温度计的温度属性, 这个可以直接使用现有的线程安全类进行替换

### 委托失效（复合操作）

这种情况就是状态之间存在着依赖关系, 导致了非原子性操作的发生, 解决方案则是加锁, 将非原子操作上锁, 作为临界区代码, 只有获取锁的线程才可以访问. 保证不变性条件不被破坏

### 发布底层的状态变量

关于这个问题其实我很困惑, 我是一个搞业务开发的javaer, 只是根据原文中案例的阅读, 感觉是外界代码有修改底层变量的需求才需要发布这个底层变量.希望阅读到此并有经验的读者可以留言告诉我具体的场景.

什么时候可以这么做? 这取决于变量是否有关联的不变性条件.有则不可以发布, 例如银行账户的金额, 没有则可以发布, 例如用户的最近登录IP.

例如一个equipment封装了一个thermometer, thermometer中封装了一个temperature属性,并且对此没有任何的不变性条件约束.那么, 可以将temperature暴露出去, 外部的公共代码也可以对这个值进行读写操作.

## 在现有线程安全的类中添加功能

场景: 现有类不支持某个特殊的操作,且不能修改源代码, 需要我们在不破坏线程安全性的情况下新增一个操作的视线.

下面则看一个案例, 需要向List中添加一个不存在则添加的功能

### 扩展基类

由于相对没有合适的同步list, 我这边就选择使用旧的Vector来演示

```java
public class ExtendList<E> extends Vector<E> {
    public synchronized boolean putIfAbsent(E e){
        boolean absent = !contains(e);
        if (absent){
            add(e);
        }
        return absent;
    }
}
```

缺点: 将同步策略分布在类中, 不好维护. 并且如果底层修改了同步策略并选择不同的锁来保护状态, 那么子类也会失去正确性.(Vector不再以内置锁的方式做并发访问策略, 那么ExtendList中的putIfAbsent也会失效)

### 客户端加锁

```java
class ListHelp<E> {
    public List<E> list = Collections.synchronizedList(new ArrayList<>());

    public boolean putIfAbsent(E e) {
        // 注意 这里要锁住的list实例,而不是ListHelp实例
        synchronized (list) {
            boolean absent = !list.contains(e);
            if (absent) {
                list.add(e);
            }
            return absent;
        }
    }
}
```

缺点: 将类C的加锁代码放在和类C完全无关的类中, 更难以维护

### 对象的组合(推荐)

```java
public class ImproveList<T> implements List<T> {
    private final List<T> list;

    public ImproveList(List<T> list) {
        this.list = list;
    }
    // 即使修改了同步策略, synchronized依旧会保证这是一个原子操作
    public synchronized boolean putIfAbsent(T e) {
        boolean absent = !list.contains(e);
        if (absent) {
            list.add(e);
        }
        return absent;
    }
}
```

实际上就是一个监视器模式, 只是选择了内置锁作为锁对象.相比扩展基类和客户端加锁的方式来拓展功能, 组合模式显然更**健壮**, 不管是list是否是线程安全的, 以及list的同步策略如何, putIfAbsent都将提供安全的加锁机制以保证线程安全性.
